{\rtf1\ansi\ansicpg1252\cocoartf1671\cocoasubrtf400
{\fonttbl\f0\fnil\fcharset0 Menlo-Italic;\f1\fnil\fcharset0 Menlo-Regular;\f2\fnil\fcharset0 Menlo-Bold;
}
{\colortbl;\red255\green255\blue255;\red83\green101\blue121;\red255\green255\blue255;\red0\green0\blue0;
\red100\green56\blue32;\red196\green26\blue22;\red155\green35\blue147;\red92\green38\blue153;\red50\green109\blue116;
\red28\green0\blue207;\red57\green0\blue160;\red63\green80\blue98;}
{\*\expandedcolortbl;;\csgenericrgb\c32401\c39745\c47507;\csgenericrgb\c100000\c100000\c100000;\csgenericrgb\c0\c0\c0;
\csgenericrgb\c39147\c22031\c12446;\csgenericrgb\c77000\c10200\c8600;\csgenericrgb\c60759\c13753\c57628;\csgenericrgb\c35922\c14825\c60191;\csgenericrgb\c19418\c42935\c45455;
\csgenericrgb\c11000\c0\c81000;\csgenericrgb\c22454\c0\c62803;\csgenericrgb\c24790\c31335\c38289;}
\margl1440\margr1440\vieww10800\viewh8400\viewkind0
\deftab741
\pard\tx741\pardeftab741\pardirnatural\partightenfactor0

\f0\i\fs30 \cf2 \cb3 //HW5 Due: April 7 (Sunday) at 11:59PM
\f1\i0 \cf4 \

\f0\i \cf2 //mjacobs@syr.edu
\f1\i0 \cf4 \
\cf5 #include \cf6 <iostream>\cf4 \
\cf5 #include \cf6 <memory>\cf4 \
\

\f2\b \cf7 using
\f1\b0 \cf4  
\f2\b \cf7 namespace
\f1\b0 \cf4  \cf8 std\cf4 ;\
\

\f2\b \cf7 class
\f1\b0 \cf4  node \{\

\f2\b \cf7 public
\f1\b0 \cf4 :\
    \cf8 shared_ptr\cf4 <\cf9 node\cf4 > east;\
    \cf8 shared_ptr\cf4 <\cf9 node\cf4 > south;\
    
\f2\b \cf7 int
\f1\b0 \cf4  value;\
    node() \{\}\
    node(
\f2\b \cf7 int
\f1\b0 \cf4  i) \{ \cf9 value\cf4  = i; \}\
\};\
\

\f2\b \cf7 class
\f1\b0 \cf4  ring \{\

\f2\b \cf7 public
\f1\b0 \cf4 :\
    
\f0\i \cf2 //Implement all functions described below
\f1\i0 \cf4 \
    
\f0\i \cf2 //funciton operator[] can be invoked by other functions
\f1\i0 \cf4 \
    \cf8 shared_ptr\cf4 <\cf9 node\cf4 > head;\
    
\f2\b \cf7 int
\f1\b0 \cf4  num_rows;\
    
\f2\b \cf7 int
\f1\b0 \cf4  num_cols;\
    ring()\{\}\
    ring(
\f2\b \cf7 int
\f1\b0 \cf4  i, 
\f2\b \cf7 int
\f1\b0 \cf4  j);
\f0\i \cf2 //constructor
\f1\i0 \cf4 \
    
\f0\i \cf2 //i rows and j cols
\f1\i0 \cf4 \
    
\f0\i \cf2 //values from 0 to i*j-1
\f1\i0 \cf4 \
    
\f0\i \cf2 //See the photo for ring structures.
\f1\i0 \cf4 \
    ~ring();
\f0\i \cf2 //destructor; do as little work as possible
\f1\i0 \cf4 \
    ring(
\f2\b \cf7 const
\f1\b0 \cf4  \cf9 ring\cf4  &r); 
\f0\i \cf2 //copy constructor
\f1\i0 \cf4 \
    ring(\cf9 ring\cf4  &&r); 
\f0\i \cf2 //move constructor
\f1\i0 \cf4 \
    
\f2\b \cf7 void
\f1\b0 \cf4  
\f2\b \cf7 operator
\f1\b0 \cf4 =(\cf9 ring\cf4  &&r);
\f0\i \cf2 //R-value operator=
\f1\i0 \cf4 \
    
\f2\b \cf7 void
\f1\b0 \cf4  
\f2\b \cf7 operator
\f1\b0 \cf4 =(
\f2\b \cf7 const
\f1\b0 \cf4  \cf9 ring\cf4  &r); 
\f0\i \cf2 //L-value operator=
\f1\i0 \cf4 \
    ring(
\f2\b \cf7 const
\f1\b0 \cf4  \cf8 initializer_list\cf4 <
\f2\b \cf7 int
\f1\b0 \cf4 > &V);
\f0\i \cf2 //see the explanation in main function
\f1\i0 \cf4 \
    
\f2\b \cf7 int
\f1\b0 \cf4  & 
\f2\b \cf7 operator
\f1\b0 \cf4 [](
\f2\b \cf7 int
\f1\b0 \cf4  a);\
    
\f2\b \cf7 int
\f1\b0 \cf4  & 
\f2\b \cf7 operator
\f1\b0 \cf4 [](\cf8 pair\cf4 <
\f2\b \cf7 int
\f1\b0 \cf4 , 
\f2\b \cf7 int
\f1\b0 \cf4 > p); 
\f0\i \cf2 //first is row number and second is col number
\f1\i0 \cf4 \
    
\f2\b \cf7 void
\f1\b0 \cf4  DelCol(
\f2\b \cf7 int
\f1\b0 \cf4  i);
\f0\i \cf2 //delete col i of *this
\f1\i0 \cf4 \
    \cf9 ring\cf4  Threetimes();\
    
\f0\i \cf2 //return a ring with the same dimenstion as *this, and the value of every node is three times of that of *this.
\f1\i0 \cf4 \
    \
\};\
\

\f0\i \cf2 //
\f1\i0 \cf4 \

\f0\i \cf2 //ring::ring(const initializer_list<int> &V)\{
\f1\i0 \cf4 \

\f0\i \cf2 //    auto it1 = V.begin();
\f1\i0 \cf4 \

\f0\i \cf2 //    while (it1!=V.end()) \{
\f1\i0 \cf4 \

\f0\i \cf2 //        shared_ptr<node> sp1 = make_shared<node>(*it1);
\f1\i0 \cf4 \

\f0\i \cf2 //        if (!head) \{ sp1 ->east = sp1;\}
\f1\i0 \cf4 \

\f0\i \cf2 //        else\{
\f1\i0 \cf4 \

\f0\i \cf2 //
\f1\i0 \cf4 \

\f0\i \cf2 //        \}
\f1\i0 \cf4 \

\f0\i \cf2 //    \}
\f1\i0 \cf4 \

\f0\i \cf2 //    it1++;
\f1\i0 \cf4 \

\f0\i \cf2 //\}
\f1\i0 \cf4 \
\
\cf9 ring\cf4 ::ring(
\f2\b \cf7 int
\f1\b0 \cf4  i, 
\f2\b \cf7 int
\f1\b0 \cf4  j)\{\
    
\f2\b \cf7 int
\f1\b0 \cf4  item = \cf10 0\cf4 ;\
    \cf8 shared_ptr\cf4 <\cf9 node\cf4 > sp1 = \cf11 make_shared\cf4 <\cf9 node\cf4 >(item); 
\f0\i \cf2 //could start with 0
\f1\i0 \cf4 \
    \cf8 shared_ptr\cf4 <\cf9 node\cf4 > sp4;\
    
\f0\i \cf2 //this first loop is to connect them to the east
\f1\i0 \cf4 \
    
\f2\b \cf7 for
\f1\b0 \cf4  (
\f2\b \cf7 int
\f1\b0 \cf4  a = \cf10 0\cf4 ; a < i ; a++) \{ 
\f0\i \cf2 //represents the rows
\f1\i0 \cf4 \
        
\f2\b \cf7 for
\f1\b0 \cf4  (
\f2\b \cf7 int
\f1\b0 \cf4  b =\cf10 0\cf4 ; b < j; b++) \{ 
\f0\i \cf2 //represents the columns
\f1\i0 \cf4 \
            
\f0\i \cf2 //check if it is the first one
\f1\i0 \cf4 \
            
\f2\b \cf7 if
\f1\b0 \cf4  (item==\cf10 0\cf4 )\{\
                \cf9 head\cf4  = sp1;\
            \}\
            
\f2\b \cf7 if
\f1\b0 \cf4  (item == ((i*j)-\cf10 1\cf4 )) \{\
                sp1->\cf9 east\cf4  = \cf9 head\cf4 ;\
                
\f2\b \cf7 break
\f1\b0 \cf4 ;\
            \}\
            
\f0\i \cf2 //all other nodes need to connect
\f1\i0 \cf4 \
            item++;\
            \cf8 shared_ptr\cf4 <\cf9 node\cf4 > sp2 = \cf11 make_shared\cf4 <\cf9 node\cf4 >(item);\
            sp1->\cf9 east\cf4  = sp2;\
            sp1 = sp2;\
        \}\
    \}\
    item = \cf10 0\cf4 ;\
    sp1 = \cf9 head\cf4 ;\
    
\f2\b \cf7 while
\f1\b0 \cf4  (item < (i-\cf10 1\cf4 )) \{ 
\f0\i \cf2 //second loops will be to connect them to the south reset things
\f1\i0 \cf4 \
        
\f2\b \cf7 for
\f1\b0 \cf4  (
\f2\b \cf7 int
\f1\b0 \cf4  a = \cf10 0\cf4 ; a < j; a++) \{\
            
\f2\b \cf7 if
\f1\b0 \cf4  (a ==\cf10 0\cf4 )\{\
            sp4 = sp1;\
            
\f2\b \cf7 for
\f1\b0 \cf4  (
\f2\b \cf7 int
\f1\b0 \cf4  b =\cf10 0\cf4 ; b < j; b++) \{\
                sp4 = sp4->\cf9 east\cf4 ;\
            \}\
            \}\
             sp1->\cf9 south\cf4  = sp4;\
            sp1 = sp1->\cf9 east\cf4 ;\
            sp4 = sp4->\cf9 east\cf4 ;\
            
\f2\b \cf7 if
\f1\b0 \cf4  (sp4->\cf9 value\cf4  == (i*j)-\cf10 1\cf4 ) \{\
                sp4->\cf9 south\cf4  = \cf9 head\cf4 ;\
                
\f0\i \cf2 //break;
\f1\i0 \cf4 \
            \}\
        \}\
        item++;\
    \}\
    item = \cf10 0\cf4 ;sp1 = \cf9 head\cf4 ;\
    
\f2\b \cf7 for
\f1\b0 \cf4  (
\f2\b \cf7 int
\f1\b0 \cf4  a=\cf10 0\cf4 ; a < j; a++) \{  
\f0\i \cf2 //connect the bottom nodes to the south top node
\f1\i0 \cf4 \
        
\f2\b \cf7 if
\f1\b0 \cf4  (a ==\cf10 0\cf4 ) \{\
            sp4 = sp1;\
            
\f2\b \cf7 for
\f1\b0 \cf4  (
\f2\b \cf7 int
\f1\b0 \cf4  b=\cf10 0\cf4 ; b < (i-\cf10 1\cf4 ); b++) \{\
                sp4 = sp4->\cf9 south\cf4 ;\
            \}\
        \}\
        sp1 = sp1->\cf9 east\cf4 ;\
        sp4->\cf9 south\cf4  = sp1;\
        sp4 = sp4->\cf9 east\cf4 ;\
        
\f2\b \cf7 if
\f1\b0 \cf4 (sp4->\cf9 value\cf4  == (i*j)-\cf10 1\cf4 )\{\
            sp4->\cf9 south\cf4  = \cf9 head\cf4 ;\
            
\f2\b \cf7 break
\f1\b0 \cf4 ;\
        \}\
    \}\
\}\
\

\f0\i \cf2 //destructor
\f1\i0 \cf4 \
\cf9 ring\cf4 ::~ring()\{\

\f0\i \cf2 //    cout << "In the destructor" << endl;
\f1\i0 \cf4 \
\}\
\

\f0\i \cf2 //copy constructor
\f1\i0 \cf4 \
\cf9 ring\cf4 ::ring(
\f2\b \cf7 const
\f1\b0 \cf4  \cf9 ring\cf4  &r)\{\
\}\
\

\f0\i \cf2 //move constructor
\f1\i0 \cf4 \
\cf9 ring\cf4 ::ring(\cf9 ring\cf4  &&r)\{\
    \
    \
\}\
\

\f2\b \cf7 int
\f1\b0 \cf4 & \cf9 ring\cf4 ::
\f2\b \cf7 operator
\f1\b0 \cf4 [](
\f2\b \cf7 int
\f1\b0 \cf4  a)\{\
    \cf8 shared_ptr\cf4 <\cf9 node\cf4 > sp1 = \cf9 head\cf4 ;\
    
\f2\b \cf7 while
\f1\b0 \cf4  (a > \cf10 0\cf4 ) \{\
        sp1 = sp1->\cf9 east\cf4 ;\
        a--;\
    \}\
    
\f2\b \cf7 return
\f1\b0 \cf4  sp1->\cf9 value\cf4 ;\
\}\
\

\f0\i \cf2 //
\f1\i0 \cf4 \

\f0\i \cf2 //int& ring::operator[](pair<int, int> p)\{
\f1\i0 \cf4 \
\cf12 ////    shared_ptr<node> sp1 = head;\cf4 \
\cf12 ////    num_rows = p.first;\cf4 \
\cf12 ////    num_cols = p.second;\cf4 \
\cf12 ////    //while () \{\cf4 \
\cf12 ////\cf4 \

\f0\i \cf2 //   // return this[p.first][p.second];
\f1\i0 \cf4 \

\f0\i \cf2 //\}
\f1\i0 \cf4 \
\

\f0\i \cf2 //
\f1\i0 \cf4 \

\f0\i \cf2 //ring::Threetimes()\{
\f1\i0 \cf4 \

\f0\i \cf2 //\}
\f1\i0 \cf4 \
\

\f0\i \cf2 //OPERATORS FOR L AND R
\f1\i0 \cf4 \

\f0\i \cf2 //R-value operator
\f1\i0 \cf4 \

\f2\b \cf7 void
\f1\b0 \cf4  \cf9 ring\cf4 ::
\f2\b \cf7 operator
\f1\b0 \cf4 =(\cf9 ring\cf4  &&r)\{\
    
\f0\i \cf2 //    shared_ptr<node> sh1;
\f1\i0 \cf4 \
    
\f0\i \cf2 //    while (head) \{
\f1\i0 \cf4 \
    
\f0\i \cf2 //        sh1 = head->east;
\f1\i0 \cf4 \
    
\f0\i \cf2 //        head.reset();
\f1\i0 \cf4 \
    
\f0\i \cf2 //        head = sh1;
\f1\i0 \cf4 \
    
\f0\i \cf2 //    \}
\f1\i0 \cf4 \
    
\f0\i \cf2 //    head.reset();
\f1\i0 \cf4 \
    
\f0\i \cf2 //    num_rows = r.num_rows;
\f1\i0 \cf4 \
    
\f0\i \cf2 //    num_cols = r.num_cols;
\f1\i0 \cf4 \
    
\f0\i \cf2 //    head = r.head;
\f1\i0 \cf4 \
    
\f0\i \cf2 //    r.num_rows = 0;
\f1\i0 \cf4 \
    
\f0\i \cf2 //    r.num_cols = 0;
\f1\i0 \cf4 \
    \cf8 cout\cf4  << \cf6 "In the r-value operator "\cf4  << \cf11 endl\cf4 ;\
\}\
\

\f0\i \cf2 //L-value operator
\f1\i0 \cf4 \

\f2\b \cf7 void
\f1\b0 \cf4  \cf9 ring\cf4 ::
\f2\b \cf7 operator
\f1\b0 \cf4 =(
\f2\b \cf7 const
\f1\b0 \cf4  \cf9 ring\cf4  &r)\{\
    
\f0\i \cf2 //    shared_ptr<node> sh1;
\f1\i0 \cf4 \
    
\f0\i \cf2 //    while (sh1) \{
\f1\i0 \cf4 \
    
\f0\i \cf2 //        sh1 = head->east;
\f1\i0 \cf4 \
    
\f0\i \cf2 //        head.reset();
\f1\i0 \cf4 \
    
\f0\i \cf2 //        head = sh1;
\f1\i0 \cf4 \
    
\f0\i \cf2 //    \}
\f1\i0 \cf4 \
    
\f0\i \cf2 //    head.reset();
\f1\i0 \cf4 \
    
\f0\i \cf2 //    num_cols = 0;
\f1\i0 \cf4 \
    
\f0\i \cf2 //    num_rows = 0;
\f1\i0 \cf4 \
    
\f0\i \cf2 //    for (int i=0; i < num_cols * num_rows; i++) \{
\f1\i0 \cf4 \
    
\f0\i \cf2 //        sh1 =
\f1\i0 \cf4 \
    
\f0\i \cf2 //    \}
\f1\i0 \cf4 \
    \cf8 cout\cf4  << \cf6 "In the l-value operator "\cf4  << \cf11 endl\cf4 ;\
\}\
\
\
\cf12 ////overload operator <<\cf4 \
\cf8 ostream\cf4  & 
\f2\b \cf7 operator
\f1\b0 \cf4 <<(\cf8 ostream\cf4  &str, 
\f2\b \cf7 const
\f1\b0 \cf4  \cf9 ring\cf4  &R) \{\
    \cf8 shared_ptr\cf4 <\cf9 node\cf4 > p = R.\cf9 head\cf4 ;\
    
\f2\b \cf7 if
\f1\b0 \cf4  (!R.\cf9 head\cf4 ) \{ 
\f2\b \cf7 return
\f1\b0 \cf4  str; \}\
    str << p->\cf9 value\cf4 << \cf6 " "\cf4 ;\
    p = p->\cf9 south\cf4 ;\
    
\f2\b \cf7 while
\f1\b0 \cf4  (p !=  R.\cf9 head\cf4 ) \{\
       
\f0\i \cf2 // cout << "You are in the print" << endl;
\f1\i0 \cf4 \
        str << p->\cf9 value\cf4  << \cf6 " "\cf4 ;\
        p = p->\cf9 south\cf4 ;\
    \}\
    
\f2\b \cf7 return
\f1\b0 \cf4  str;\
\}\
\
\

\f2\b \cf7 int
\f1\b0 \cf4  main() \{\
    \
    \cf9 ring\cf4  R1(\cf10 4\cf4 , \cf10 6\cf4 );
\f0\i \cf2 //24 numbers from 0 to 23 will be initialized to nodes.
\f1\i0 \cf4 \
    \cf8 cout\cf4  << R1 << \cf11 endl\cf4 ;\

\f0\i \cf2 //     R1[14] = 1000;
\f1\i0 \cf4 \

\f0\i \cf2 //     R1[\{2, 4\}] = 2000;
\f1\i0 \cf4 \

\f0\i \cf2 //     cout << R1[14] << " " << R1[\{2, 4\}] << endl;
\f1\i0 \cf4 \

\f0\i \cf2 //    R1.DelCol(3);
\f1\i0 \cf4 \

\f0\i \cf2 //    cout << R1 << endl;
\f1\i0 \cf4 \

\f0\i \cf2 //    R1.DelCol(4);
\f1\i0 \cf4 \

\f0\i \cf2 //    cout << R1 << endl;
\f1\i0 \cf4 \

\f0\i \cf2 //    R1.DelCol(0);
\f1\i0 \cf4 \

\f0\i \cf2 //    cout << R1 << endl;
\f1\i0 \cf4 \

\f0\i \cf2 //    shared_ptr<ring> p1 = make_shared<ring>(3, 5);
\f1\i0 \cf4 \

\f0\i \cf2 //    cout << *p1 << endl;
\f1\i0 \cf4 \

\f0\i \cf2 //    p1.reset();
\f1\i0 \cf4 \

\f0\i \cf2 //    ring R2 = \{ 3, 5, 10,20,30,40,50, 100, 200, 300, 400, 500, 1000, 2000, 3000, 4000, 5000 \};//
\f1\i0 \cf4 \

\f0\i \cf2 //    //first two numbers are num_rows and num_cols; followed by values of nodes of ring
\f1\i0 \cf4 \

\f0\i \cf2 //    cout << R2 << endl;
\f1\i0 \cf4 \

\f0\i \cf2 //    ring R3(R2);
\f1\i0 \cf4 \

\f0\i \cf2 //    cout << R3 << endl;
\f1\i0 \cf4 \

\f0\i \cf2 //    ring R4;
\f1\i0 \cf4 \

\f0\i \cf2 //    R4 = R3;
\f1\i0 \cf4 \

\f0\i \cf2 //    cout << R4 << endl;
\f1\i0 \cf4 \

\f0\i \cf2 //    ring R5;
\f1\i0 \cf4 \

\f0\i \cf2 //    R5 = R4.Threetimes();
\f1\i0 \cf4 \

\f0\i \cf2 //    cout << R5 << endl;
\f1\i0 \cf4 \
    \
    \cf11 getchar\cf4 ();\
    \cf11 getchar\cf4 ();\
    
\f2\b \cf7 return
\f1\b0 \cf4  \cf10 0\cf4 ;\
\}\
}